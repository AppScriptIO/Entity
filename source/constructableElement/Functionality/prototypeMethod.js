"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports, "__esModule", { value: true });exports.createSwitch = exports.mergeOwnNestedPropertyCurried = exports.nestedPropertyDelegatedLookupCurried = void 0;var _assert = _interopRequireDefault(require("assert"));
var _isGeneratorFunction = require("../../utility/isGeneratorFunction.js");
var _delegatedLookup = require("../../utility/delegatedLookup.js");
var _mergeProperty = require("../../utility/mergeProperty.js");
var _getNestedObject = require("../../utility/getNestedObject.js");

const nestedPropertyDelegatedLookupCurried = ({ baseProperty }) => {
  if (!Array.isArray(baseProperty)) baseProperty = [baseProperty];
  return function (implementationKey, recursive = false, callerClass = this) {
    (0, _assert.default)(implementationKey, `• implementationKey must be passed, cannot be undefined.`);
    return (0, _delegatedLookup.nestedPropertyDelegatedLookup)({
      target: callerClass,
      propertyPath: [...baseProperty, implementationKey],
      recursive });

  };
};exports.nestedPropertyDelegatedLookupCurried = nestedPropertyDelegatedLookupCurried;

const mergeOwnNestedPropertyCurried = ({ property }) => {
  if (!Array.isArray(property)) property = [property];
  return function (implementation) {
    return (0, _mergeProperty.mergeOwnNestedProperty)({ target: this, propertyPath: property, value: implementation });
  };
};exports.mergeOwnNestedPropertyCurried = mergeOwnNestedPropertyCurried;




function lookupImplementation({ implementationKey, fallbackPropertyPath, callerClass = this, implementationGetterPropertyPath, recursiveDelegationChainExecution }) {
  implementationKey || (implementationKey = (0, _getNestedObject.getNestedObject)(callerClass, fallbackPropertyPath));
  let lookupResult;
  let implementationGetter = (0, _getNestedObject.getNestedObject)(callerClass, implementationGetterPropertyPath);
  if (recursiveDelegationChainExecution) {
    lookupResult = implementationGetter.call(callerClass, implementationKey, true);
    (0, _assert.default)(lookupResult && lookupResult.length > 0, `• No implementation constructor found for key ${implementationKey.toString()}`);
  } else {

    lookupResult = implementationGetter.call(callerClass, implementationKey);
    (0, _assert.default)(lookupResult, `• No implementation constructor found for key ${implementationKey && implementationKey.toString() || implementationKey}`);
  }
  if (!Array.isArray(lookupResult)) lookupResult = [lookupResult];

  return lookupResult;
}






const createSwitch = ({ fallbackPropertyPath, implementationGetterPropertyPath }) => {

  return function switchInterface(
  implementationKey,
  {



    recursiveDelegationChainExecution = false,
    executionAlgorithm,
    callerClass = this } =
  {})
  {

    let implementationArray = lookupImplementation.call(callerClass, { implementationKey, fallbackPropertyPath, implementationGetterPropertyPath, recursiveDelegationChainExecution });
    if (implementationArray.length == 0) return function () {};

    {

      function provideAsCallbackInFunctionChain() {
        function createCallbackFunc(targetFunction, superCallback) {
          let funcCallback;






          if ((0, _isGeneratorFunction.isGeneratorFunction)(targetFunction))
          funcCallback = function () {
            let iterator = targetFunction.call(this, ...arguments);
            let iteratorObject = iterator.next({ superCallback });
            (0, _assert.default)(iteratorObject.done, `• Generator implementation function must not yield results, only recieve the superCallback and return a value.`);
            return iteratorObject.value;
          };else
          funcCallback = targetFunction;

          return funcCallback;
        }

        implementationArray.reverse();
        let previousLoopCallback = null;
        for (let index = 0; index < implementationArray.length; index++) {
          let currentFunction = implementationArray[index];
          let callback = createCallbackFunc(currentFunction, previousLoopCallback);
          previousLoopCallback = callback;
        }
        let result = previousLoopCallback.call(callerClass, ...arguments);
        return result;
      }

      switch (executionAlgorithm) {
        case 'provideAsCallbackInFunctionChain':
        default:
          return provideAsCallbackInFunctionChain;
          break;}

    }
  };
};exports.createSwitch = createSwitch;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NvdXJjZS9jb25zdHJ1Y3RhYmxlRWxlbWVudC9GdW5jdGlvbmFsaXR5L3Byb3RvdHlwZU1ldGhvZC5qcyJdLCJuYW1lcyI6WyJuZXN0ZWRQcm9wZXJ0eURlbGVnYXRlZExvb2t1cEN1cnJpZWQiLCJiYXNlUHJvcGVydHkiLCJBcnJheSIsImlzQXJyYXkiLCJpbXBsZW1lbnRhdGlvbktleSIsInJlY3Vyc2l2ZSIsImNhbGxlckNsYXNzIiwidGFyZ2V0IiwicHJvcGVydHlQYXRoIiwibWVyZ2VPd25OZXN0ZWRQcm9wZXJ0eUN1cnJpZWQiLCJwcm9wZXJ0eSIsImltcGxlbWVudGF0aW9uIiwidmFsdWUiLCJsb29rdXBJbXBsZW1lbnRhdGlvbiIsImZhbGxiYWNrUHJvcGVydHlQYXRoIiwiaW1wbGVtZW50YXRpb25HZXR0ZXJQcm9wZXJ0eVBhdGgiLCJyZWN1cnNpdmVEZWxlZ2F0aW9uQ2hhaW5FeGVjdXRpb24iLCJsb29rdXBSZXN1bHQiLCJpbXBsZW1lbnRhdGlvbkdldHRlciIsImxlbmd0aCIsInRvU3RyaW5nIiwiY3JlYXRlU3dpdGNoIiwic3dpdGNoSW50ZXJmYWNlIiwiZXhlY3V0aW9uQWxnb3JpdGhtIiwiaW1wbGVtZW50YXRpb25BcnJheSIsInByb3ZpZGVBc0NhbGxiYWNrSW5GdW5jdGlvbkNoYWluIiwiY3JlYXRlQ2FsbGJhY2tGdW5jIiwidGFyZ2V0RnVuY3Rpb24iLCJzdXBlckNhbGxiYWNrIiwiZnVuY0NhbGxiYWNrIiwiaXRlcmF0b3IiLCJhcmd1bWVudHMiLCJpdGVyYXRvck9iamVjdCIsIm5leHQiLCJkb25lIiwicmV2ZXJzZSIsInByZXZpb3VzTG9vcENhbGxiYWNrIiwiaW5kZXgiLCJjdXJyZW50RnVuY3Rpb24iLCJjYWxsYmFjayIsInJlc3VsdCJdLCJtYXBwaW5ncyI6InFSQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sTUFBTUEsb0NBQW9DLEdBQUcsQ0FBQyxFQUFFQyxZQUFGLEVBQUQsS0FBc0I7QUFD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b20gJ2Fzc2VydCdcbmltcG9ydCB7IGlzR2VuZXJhdG9yRnVuY3Rpb24gfSBmcm9tICcuLi8uLi91dGlsaXR5L2lzR2VuZXJhdG9yRnVuY3Rpb24uanMnXG5pbXBvcnQgeyBuZXN0ZWRQcm9wZXJ0eURlbGVnYXRlZExvb2t1cCB9IGZyb20gJy4uLy4uL3V0aWxpdHkvZGVsZWdhdGVkTG9va3VwLmpzJ1xuaW1wb3J0IHsgbWVyZ2VPd25OZXN0ZWRQcm9wZXJ0eSB9IGZyb20gJy4uLy4uL3V0aWxpdHkvbWVyZ2VQcm9wZXJ0eS5qcydcbmltcG9ydCB7IGdldE5lc3RlZE9iamVjdCB9IGZyb20gJy4uLy4uL3V0aWxpdHkvZ2V0TmVzdGVkT2JqZWN0LmpzJ1xuXG5leHBvcnQgY29uc3QgbmVzdGVkUHJvcGVydHlEZWxlZ2F0ZWRMb29rdXBDdXJyaWVkID0gKHsgYmFzZVByb3BlcnR5IH0pID0+IHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGJhc2VQcm9wZXJ0eSkpIGJhc2VQcm9wZXJ0eSA9IFtiYXNlUHJvcGVydHldXG4gIHJldHVybiBmdW5jdGlvbihpbXBsZW1lbnRhdGlvbktleTogU3RyaW5nLCByZWN1cnNpdmU6IEJvb2xlYW4gPSBmYWxzZSwgY2FsbGVyQ2xhc3MgPSB0aGlzKSB7XG4gICAgYXNzZXJ0KGltcGxlbWVudGF0aW9uS2V5LCBg4oCiIGltcGxlbWVudGF0aW9uS2V5IG11c3QgYmUgcGFzc2VkLCBjYW5ub3QgYmUgdW5kZWZpbmVkLmApXG4gICAgcmV0dXJuIG5lc3RlZFByb3BlcnR5RGVsZWdhdGVkTG9va3VwKHtcbiAgICAgIHRhcmdldDogY2FsbGVyQ2xhc3MsXG4gICAgICBwcm9wZXJ0eVBhdGg6IFsuLi5iYXNlUHJvcGVydHksIGltcGxlbWVudGF0aW9uS2V5XSxcbiAgICAgIHJlY3Vyc2l2ZSxcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBtZXJnZU93bk5lc3RlZFByb3BlcnR5Q3VycmllZCA9ICh7IHByb3BlcnR5IH0pID0+IHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BlcnR5KSkgcHJvcGVydHkgPSBbcHJvcGVydHldXG4gIHJldHVybiBmdW5jdGlvbihpbXBsZW1lbnRhdGlvbjogT2JqZWN0KSB7XG4gICAgcmV0dXJuIG1lcmdlT3duTmVzdGVkUHJvcGVydHkoeyB0YXJnZXQ6IHRoaXMsIHByb3BlcnR5UGF0aDogcHJvcGVydHksIHZhbHVlOiBpbXBsZW1lbnRhdGlvbiB9KVxuICB9XG59XG5cbi8qKlxuICogQHJldHVybiB7QXJyYXk8T2JqZWN0Pn1cbiAqL1xuZnVuY3Rpb24gbG9va3VwSW1wbGVtZW50YXRpb24oeyBpbXBsZW1lbnRhdGlvbktleSwgZmFsbGJhY2tQcm9wZXJ0eVBhdGgsIGNhbGxlckNsYXNzID0gdGhpcywgaW1wbGVtZW50YXRpb25HZXR0ZXJQcm9wZXJ0eVBhdGgsIHJlY3Vyc2l2ZURlbGVnYXRpb25DaGFpbkV4ZWN1dGlvbiB9KSB7XG4gIGltcGxlbWVudGF0aW9uS2V5IHx8PSBnZXROZXN0ZWRPYmplY3QoY2FsbGVyQ2xhc3MsIGZhbGxiYWNrUHJvcGVydHlQYXRoKVxuICBsZXQgbG9va3VwUmVzdWx0IC8vIGltcGxlbWVudGF0aW9uIGZ1bmN0aW9ucyB0byBleGVjdXRlXG4gIGxldCBpbXBsZW1lbnRhdGlvbkdldHRlciA9IGdldE5lc3RlZE9iamVjdChjYWxsZXJDbGFzcywgaW1wbGVtZW50YXRpb25HZXR0ZXJQcm9wZXJ0eVBhdGgpIC8vIHJldHVybnMgYXMgbmVzdGVkIHByb3BlcnR5LCBpbiB0aGlzIGNhc2UgaXQgaXMgYSBnZXR0ZXIgZnVuY3Rpb25cbiAgaWYgKHJlY3Vyc2l2ZURlbGVnYXRpb25DaGFpbkV4ZWN1dGlvbikge1xuICAgIGxvb2t1cFJlc3VsdCA9IGNhbGxlckNsYXNzOjppbXBsZW1lbnRhdGlvbkdldHRlcihpbXBsZW1lbnRhdGlvbktleSwgdHJ1ZSAvKnJlY3Vyc2l2ZSBleGVjdXRpb24gb2YgbXVsdGlwbGUgaW1wbGVtZW50YXRpb25zKi8pXG4gICAgYXNzZXJ0KGxvb2t1cFJlc3VsdCAmJiBsb29rdXBSZXN1bHQubGVuZ3RoID4gMCwgYOKAoiBObyBpbXBsZW1lbnRhdGlvbiBjb25zdHJ1Y3RvciBmb3VuZCBmb3Iga2V5ICR7aW1wbGVtZW50YXRpb25LZXkudG9TdHJpbmcoKX1gKVxuICB9IGVsc2Uge1xuICAgIC8vIHNpbmdsZSBpbXBsZW1lbnRhdGlvblxuICAgIGxvb2t1cFJlc3VsdCA9IGNhbGxlckNsYXNzOjppbXBsZW1lbnRhdGlvbkdldHRlcihpbXBsZW1lbnRhdGlvbktleSlcbiAgICBhc3NlcnQobG9va3VwUmVzdWx0LCBg4oCiIE5vIGltcGxlbWVudGF0aW9uIGNvbnN0cnVjdG9yIGZvdW5kIGZvciBrZXkgJHsoaW1wbGVtZW50YXRpb25LZXkgJiYgaW1wbGVtZW50YXRpb25LZXkudG9TdHJpbmcoKSkgfHwgaW1wbGVtZW50YXRpb25LZXl9YClcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkobG9va3VwUmVzdWx0KSkgbG9va3VwUmVzdWx0ID0gW2xvb2t1cFJlc3VsdF0gLy8gZm9yIHByZXZlbnRpbmcgc2VwYXJhdGUgY29kZSBmb3IgZXhlY3V0aW9uLlxuICAvLyBwcmVwYXJhdGUgZnVuY3Rpb25zIHJlZ2lzdGVyZWQgZm9yIGEgc3BlY2lmaWMgaW1wbGVtZW50YXRpb25cbiAgcmV0dXJuIGxvb2t1cFJlc3VsdFxufVxuXG4vKipcbiAqIENoYW5nZSBpbnRlcmZhY2UgYmVoYXZpb3IgZm9yIG5vbiBnZW5lcmF0b3IgdGFyZ2V0cyAtIGV4cG9zZSBnZW5lcmF0b3IgYXMgcmVndWxhciBmdW5jdGlvbiBmb3IgcXVpY2sgbm9uIHByb3BhZ2F0aW5nIGNhbGxzLlxuICogV2hlbiB0aGUgZ2VuZXJhdG9yJ3MgaXRlcmF0b3IgaXMgY2FsbGVkIHRoZSBjb25zdHJ1Y3QgdHJhcCB3aWxsIGl0ZXJhdGUgb3ZlciBpdCBhbmQgcmV0dXJuIHRoZSByZXN1bHQuXG4gKiBAcGFyYW0gaW1wbGVtZW50YXRpb25HZXR0ZXJQcm9wZXJ0eVBhdGggdGhlIGdldHRlciBmdW5jdGlvbiBmb3IgdGhlIGltcGxlbWVudGF0aW9uIHVzaW5nIGl0cyBrZXkuXG4gKiovXG5leHBvcnQgY29uc3QgY3JlYXRlU3dpdGNoID0gKHsgZmFsbGJhY2tQcm9wZXJ0eVBhdGgsIGltcGxlbWVudGF0aW9uR2V0dGVyUHJvcGVydHlQYXRoIH0pID0+IHtcbiAgLy8gZXhwb3NlIGFuIGludGVyZmFjZSB3aXRoIHR3byBzdWJzZXF1ZW50IGZ1bmN0aW9uIGNhbGxzXG4gIHJldHVybiBmdW5jdGlvbiBzd2l0Y2hJbnRlcmZhY2UoXG4gICAgaW1wbGVtZW50YXRpb25LZXk6IHN0cmluZyxcbiAgICB7XG4gICAgICAvKiBMaWtlIHRoZSBuYXRpdmUgSlMgYmVoYXZpb3IgZm9yIGBjb25zdHJ1Y3RvcmAgZnVuY3Rpb24gdGhhdCBjYWxscyB0aGUgc3VwZXIgY29uc3RydWN0b3IgYXMgd2VsbCBpbiB0aGUgY2hhaW4uXG4gICAgICBObyBsb25nZXIgYXBwbGllZDogLy8vLyBGdW5jdGlvbnMgdXNpbmcgcmVjdXJzaXZlIG9wdGlvbiBtdXN0IGZvbGxvdyB0aGUgZnVuY3Rpb24gZGVmaW5pdGlvbiAtICBmdW5jdGlvbihhcmd1bWVudExpc3Q8T2JqZWN0PiwgcHJldmlvdXNSZXN1bHQ8YW55PilcbiAgICAqL1xuICAgICAgcmVjdXJzaXZlRGVsZWdhdGlvbkNoYWluRXhlY3V0aW9uID0gZmFsc2UsIC8vIEV4ZWN1dGUgYWxsIGZ1bmN0aW9ucyBpbiB0aGUgZGVsZWdhdGlvbiBjaGFpbiB0aGF0IG1hdGNoIHRoZSBgaW1wbGVtZW50YXRpb25LZXlgIHZhbHVlLiBlLmcuIHVzZSBpbml0aWFsaXphdGlvbiBmdW5jdGlvbiBmcm9tIGVhY2ggY2xhc3MgaW4gdGhlIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgIGV4ZWN1dGlvbkFsZ29yaXRobSwgLy8gZGVjaWRlcyB0aGUgaW50ZXJmYWNlIHVzZWQgaW4gZXhlY3V0aW5nIHRoZSBpbXBsZW1lbmF0aW9uc1xuICAgICAgY2FsbGVyQ2xhc3MgPSB0aGlzLCAvLyB0aGUgY29uc3RydWN0YWJsZSBjbGFzcyB0aGF0IGluaXRpYXRlZCB0aGUgZnVuY3Rpb24gY2FsbC5cbiAgICB9ID0ge30sXG4gICkge1xuICAgIC8vIGxvb2t1cCBpbXBsZW1lbnRhdGlvbiBmdW5jdGlvbnM6XG4gICAgbGV0IGltcGxlbWVudGF0aW9uQXJyYXkgPSBjYWxsZXJDbGFzczo6bG9va3VwSW1wbGVtZW50YXRpb24oeyBpbXBsZW1lbnRhdGlvbktleSwgZmFsbGJhY2tQcm9wZXJ0eVBhdGgsIGltcGxlbWVudGF0aW9uR2V0dGVyUHJvcGVydHlQYXRoLCByZWN1cnNpdmVEZWxlZ2F0aW9uQ2hhaW5FeGVjdXRpb24gfSlcbiAgICBpZiAoaW1wbGVtZW50YXRpb25BcnJheS5sZW5ndGggPT0gMCkgcmV0dXJuIGZ1bmN0aW9uKCkge30gLy8gcmV0dXJuIGVtcHR5IGR1bW15IGZ1bmN0aW9uIHRvIGtlZXAgdGhlIGZsb3cgb2YgdGhlIGNsaWVudCBjb2RlLlxuICAgIC8vIGV4ZWN1dGlvbiBhbGdvcml0aG0gc3dpdGNoXG4gICAge1xuICAgICAgLyoqIFNlbmQgdGhlIHBhcmVudCBpbXBsZW1lbnRhdGlvbiBhcyBjYWxsYmFjayB0byB0aGUgY2hpbGQgaW1wbGVtZW50YXRpb24gZnVuY3Rpb24gdXNpbmcgR2VuZXJhdG9ycyBgZnVuY3Rpb24uc2VudGAgKi9cbiAgICAgIGZ1bmN0aW9uIHByb3ZpZGVBc0NhbGxiYWNrSW5GdW5jdGlvbkNoYWluKCkge1xuICAgICAgICBmdW5jdGlvbiBjcmVhdGVDYWxsYmFja0Z1bmModGFyZ2V0RnVuY3Rpb24sIHN1cGVyQ2FsbGJhY2spIHtcbiAgICAgICAgICBsZXQgZnVuY0NhbGxiYWNrXG4gICAgICAgICAgLyogRGVhbCB3aXRoIGRpZmZlcmVudCBmdW5jdGlvbiB0eXBlcyAtIHJlZGlyZWN0IGNvbnN0cnVjdCB0byBwYXJ0aWN1bGFyIGltcGxlbWVudGF0aW9uIHVzaW5nIHNwZWNpZmljIGV4ZWN1dGlvbiBkZXBlbmRpbmcgb2YgZnVuY3Rpb24gdHlwZS4gICAgICAgIFxuICAgICAgICAgICAgICAgVXNhZ2U6IGBgYGZ1bmN0aW9uKiBpbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGxldCB7IHN1cGVyQ2FsbGJhY2sgfSA9IGZ1bmN0aW9uLnNlbnRcbiAgICAgICAgICAgICAgICAgIGlmIChzdXBlckNhbGxiYWNrKSBpbnN0YW5jZSA9IGNhbGxlckNsYXNzOjpzdXBlckNhbGxiYWNrKC4uLmFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICB9YGBgXG4gICAgICAgICAgICAqL1xuICAgICAgICAgIGlmIChpc0dlbmVyYXRvckZ1bmN0aW9uKHRhcmdldEZ1bmN0aW9uKSlcbiAgICAgICAgICAgIGZ1bmNDYWxsYmFjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBsZXQgaXRlcmF0b3IgPSB0aGlzOjp0YXJnZXRGdW5jdGlvbiguLi5hcmd1bWVudHMpXG4gICAgICAgICAgICAgIGxldCBpdGVyYXRvck9iamVjdCA9IGl0ZXJhdG9yLm5leHQoeyBzdXBlckNhbGxiYWNrIH0pXG4gICAgICAgICAgICAgIGFzc2VydChpdGVyYXRvck9iamVjdC5kb25lLCBg4oCiIEdlbmVyYXRvciBpbXBsZW1lbnRhdGlvbiBmdW5jdGlvbiBtdXN0IG5vdCB5aWVsZCByZXN1bHRzLCBvbmx5IHJlY2lldmUgdGhlIHN1cGVyQ2FsbGJhY2sgYW5kIHJldHVybiBhIHZhbHVlLmApXG4gICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvck9iamVjdC52YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgZnVuY0NhbGxiYWNrID0gdGFyZ2V0RnVuY3Rpb24gLy8gaW4gY2FzZSBhIHJlZ3VsYXIgZnVuY3Rpb24sIHRoZW4gdGhlIHN1cGVyQ2FsbGJhY2sgd2lsbCBub3QgYmUgcGFzc2VkIGFuZCBzbyB0aGUgZXhlY3V0aW9uIGNoYWluIHdpbGwgYnJlYWsuXG5cbiAgICAgICAgICByZXR1cm4gZnVuY0NhbGxiYWNrXG4gICAgICAgIH1cblxuICAgICAgICBpbXBsZW1lbnRhdGlvbkFycmF5LnJldmVyc2UoKSAvLyBzdGFydCBmcm9tIHBhcmVudCBpbXBsZW1lbnRhdGlvbnMgLSB3aWxsIHJlc3VsdCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOiBbPHBhcmVudD4sIC4uLiAsIDxjaGlsZD5dIGluIGhpZXJhcmNoeSBvZiBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgbGV0IHByZXZpb3VzTG9vcENhbGxiYWNrID0gbnVsbFxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgaW1wbGVtZW50YXRpb25BcnJheS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBsZXQgY3VycmVudEZ1bmN0aW9uID0gaW1wbGVtZW50YXRpb25BcnJheVtpbmRleF1cbiAgICAgICAgICBsZXQgY2FsbGJhY2sgPSBjcmVhdGVDYWxsYmFja0Z1bmMoY3VycmVudEZ1bmN0aW9uLCBwcmV2aW91c0xvb3BDYWxsYmFjaylcbiAgICAgICAgICBwcmV2aW91c0xvb3BDYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IGNhbGxlckNsYXNzOjpwcmV2aW91c0xvb3BDYWxsYmFjayguLi5hcmd1bWVudHMpIC8vIHRoZSBsb3dlc3QgaW1wbGVtZW50YXRpb24gaW4gZGVsZWdhdGlvbiBoaWVyYXJjaHlcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGV4ZWN1dGlvbkFsZ29yaXRobSkge1xuICAgICAgICBjYXNlICdwcm92aWRlQXNDYWxsYmFja0luRnVuY3Rpb25DaGFpbic6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHByb3ZpZGVBc0NhbGxiYWNrSW5GdW5jdGlvbkNoYWluXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdfQ==