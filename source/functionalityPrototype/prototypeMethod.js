"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports, "__esModule", { value: true });exports.createSwitchGeneratorFunction = exports.mergeOwnNestedPropertyCurried = exports.nestedPropertyDelegatedLookupCurried = void 0;var _skipFirstGeneratorNext2 = _interopRequireDefault(require("@babel/runtime/helpers/skipFirstGeneratorNext"));var _assert = _interopRequireDefault(require("assert"));
var _isGeneratorFunction = require("../utility/isGeneratorFunction.js");
var _generatorExecutionControl = require("../utility/generatorExecutionControl.js");
var _propertyDelegatedLookup = require("../utility/propertyDelegatedLookup.js");
var _mergeProperty = require("../utility/mergeProperty.js");
var _getNestedObject = require("../utility/getNestedObject.js");

const nestedPropertyDelegatedLookupCurried = ({ baseProperty }) => {
  if (!Array.isArray(baseProperty)) baseProperty = [baseProperty];
  return function (implementationKey, recursive = false, callerClass = this) {
    (0, _assert.default)(implementationKey, `• implementationKey must be passed.`);
    return (0, _propertyDelegatedLookup.nestedPropertyDelegatedLookup)({
      target: callerClass,
      propertyPath: [...baseProperty, implementationKey],
      recursive });

  };
};exports.nestedPropertyDelegatedLookupCurried = nestedPropertyDelegatedLookupCurried;

const mergeOwnNestedPropertyCurried = ({ property }) => {
  if (!Array.isArray(property)) property = [property];
  return function (implementation) {
    return (0, _mergeProperty.mergeOwnNestedProperty)({ target: this, propertyPath: property, value: implementation });
  };
};exports.mergeOwnNestedPropertyCurried = mergeOwnNestedPropertyCurried;


const createSwitchGeneratorFunction = function ({
  fallbackPropertyPath,
  implementationGetterPropertyPath })
{
  if (!Array.isArray(fallbackPropertyPath)) fallbackPropertyPath = [fallbackPropertyPath];
  if (!Array.isArray(implementationGetterPropertyPath)) implementationGetterPropertyPath = [implementationGetterPropertyPath];

  let generatorFunction = (function () {let _ref = function* ({
      implementationKey,



      recursiveDelegationChainExecution = false,
      callerClass = this } =
    {}) {let _functionSent = yield;
      const controlArg = _functionSent,
      shouldHandOver = _generatorExecutionControl.executionControl.shouldHandOver(controlArg),
      shouldPropagate = _generatorExecutionControl.executionControl.shouldPropagate(controlArg);

      implementationKey || (implementationKey = (0, _getNestedObject.getNestedObject)(callerClass, fallbackPropertyPath));

      let implementation, lookupResult;
      let implementationGetter = (0, _getNestedObject.getNestedObject)(callerClass, implementationGetterPropertyPath);
      if (recursiveDelegationChainExecution) {var _context;
        lookupResult = (_context = callerClass, implementationGetter).call(_context, implementationKey, true);
        (0, _assert.default)(lookupResult && lookupResult.length > 0, `• No implementation constructor found for key ${implementationKey.toString()}`);
      } else {var _context2;

        lookupResult = (_context2 = callerClass, implementationGetter).call(_context2, implementationKey);
        (0, _assert.default)(lookupResult, `• No implementation constructor found for key ${implementationKey && implementationKey.toString() || implementationKey}`);
      }
      if (!Array.isArray(lookupResult)) lookupResult = [lookupResult];
      implementation = lookupResult.map((func, index) => {
        return { func: func, passThroughArg: {} };
      });

      let result = null;
      for (let index in implementation) {var _context3;

        if (shouldHandOver) implementation[index].passThroughArg = _functionSent = yield implementation[index].passThroughArg;
        let currentResult = (_context3 = callerClass, implementation[index].func).call(_context3, implementation[index].passThroughArg, result);


        if ((0, _isGeneratorFunction.isGeneratorFunction)(implementation[index].func)) {
          if (shouldPropagate) {


            result = _functionSent = yield* currentResult;
          } else {var _g;
            result = (_g = currentResult, _g.next('complete').value);
          }
        } else {

          result = currentResult;
        }
      }

      return result;
    },_ref2 = (0, _skipFirstGeneratorNext2.default)(_ref);return new Proxy(_ref, { apply(target, thisArgument, argumentsList) {return Reflect.apply(_ref2, thisArgument, argumentsList);} });})();

  return generatorFunction;
};exports.createSwitchGeneratorFunction = createSwitchGeneratorFunction;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NvdXJjZS9mdW5jdGlvbmFsaXR5UHJvdG90eXBlL3Byb3RvdHlwZU1ldGhvZC5qcyJdLCJuYW1lcyI6WyJuZXN0ZWRQcm9wZXJ0eURlbGVnYXRlZExvb2t1cEN1cnJpZWQiLCJiYXNlUHJvcGVydHkiLCJBcnJheSIsImlzQXJyYXkiLCJpbXBsZW1lbnRhdGlvbktleSIsInJlY3Vyc2l2ZSIsImNhbGxlckNsYXNzIiwidGFyZ2V0IiwicHJvcGVydHlQYXRoIiwibWVyZ2VPd25OZXN0ZWRQcm9wZXJ0eUN1cnJpZWQiLCJwcm9wZXJ0eSIsImltcGxlbWVudGF0aW9uIiwidmFsdWUiLCJjcmVhdGVTd2l0Y2hHZW5lcmF0b3JGdW5jdGlvbiIsImZhbGxiYWNrUHJvcGVydHlQYXRoIiwiaW1wbGVtZW50YXRpb25HZXR0ZXJQcm9wZXJ0eVBhdGgiLCJnZW5lcmF0b3JGdW5jdGlvbiIsInJlY3Vyc2l2ZURlbGVnYXRpb25DaGFpbkV4ZWN1dGlvbiIsImNvbnRyb2xBcmciLCJzaG91bGRIYW5kT3ZlciIsImV4ZWN1dGlvbkNvbnRyb2wiLCJzaG91bGRQcm9wYWdhdGUiLCJsb29rdXBSZXN1bHQiLCJpbXBsZW1lbnRhdGlvbkdldHRlciIsImxlbmd0aCIsInRvU3RyaW5nIiwibWFwIiwiZnVuYyIsImluZGV4IiwicGFzc1Rocm91Z2hBcmciLCJyZXN1bHQiLCJjdXJyZW50UmVzdWx0IiwiZyIsIm5leHQiXSwibWFwcGluZ3MiOiJzWkFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sTUFBTUEsb0NBQW9DLEdBQUcsQ0FBQyxFQUFFQyxZQUFGLEVBQUQsS0FBc0I7QUFDeEUsTUFBSSxDQUFDQyxLQUFLLENBQUNDLE9BQU4sQ0FBY0YsWUFBZCxDQUFMLEVBQWtDQSxZQUFZLEdBQUcsQ0FBQ0EsWUFBRCxDQUFmO0FBQ2xDLFNBQU8sVUFBU0csaUJBQVQsRUFBb0NDLFNBQWtCLEdBQUcsS0FBekQsRUFBZ0VDLFdBQVcsR0FBRyxJQUE5RSxFQUFv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QUNBLFdBQUssSUFBSUYsS0FBVCxJQUFrQmpCLGNBQWxCLEVBQWtDOztBQUVoQyxZQUFJUSxjQUFKLEVBQW9CUixjQUFjLENBQUNpQixLQUFELENBQWQsQ0FBc0JDLGNBQXRCLG1CQUF1QyxNQUFNbEIsY0FBYyxDQUFDaUIsS0FBRCxDQUFkLENBQXNCQyxjQUFuRTtBQUNwQixZQUFJRSxhQUFhLEdBQUcsYUFBQXpCLFdBQVcsRUFBRUssY0FBYyxDQUFDaUIsS0FBRCxDQUFkLENBQXNCRCxJQUFuQyxrQkFBd0NoQixjQUFjLENBQUNpQixLQUFELENBQWQsQ0FBc0JDLGNBQTlELEVBQThFQyxNQUE5RSxDQUFwQjs7O0FBR0EsWUFBSSw4Q0FBb0JuQixjQUFjLENBQUNpQixLQUFELENBQWQsQ0FBc0JELElBQTFDLENBQUosRUFBcUQ7QUFDbkQsY0FBSU4sZUFBSixFQUFxQjs7O0FBR25CUyxZQUFBQSxNQUFNLG1CQUFHLE9BQU9DLGFBQWhCO0FBQ0QsV0FKRCxNQUlPO0FBQ0xELFlBQUFBLE1BQU0sU0FBR0MsYUFBSCxFQUEwQkMsRUFBQyxDQUFDQyxJQUFGLENBQU8sVUFBUCxFQUFtQnJCLEtBQTdDLENBQU47QUFDRDtBQUNGLFNBUkQsTUFRTzs7QUFFTGtCLFVBQUFBLE1BQU0sR0FBR0MsYUFBVDtBQUNEO0FBQ0Y7O0FBRUQsYUFBT0QsTUFBUDtBQUNELEtBbkRvQiw0TEFBckI7O0FBcURBLFNBQU9kLGlCQUFQO0FBQ0QsQ0E3RE0sQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0J1xuaW1wb3J0IHsgaXNHZW5lcmF0b3JGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWxpdHkvaXNHZW5lcmF0b3JGdW5jdGlvbi5qcydcbmltcG9ydCB7IGV4ZWN1dGlvbkNvbnRyb2wgfSBmcm9tICcuLi91dGlsaXR5L2dlbmVyYXRvckV4ZWN1dGlvbkNvbnRyb2wuanMnXG5pbXBvcnQgeyBuZXN0ZWRQcm9wZXJ0eURlbGVnYXRlZExvb2t1cCB9IGZyb20gJy4uL3V0aWxpdHkvcHJvcGVydHlEZWxlZ2F0ZWRMb29rdXAuanMnXG5pbXBvcnQgeyBtZXJnZU93bk5lc3RlZFByb3BlcnR5IH0gZnJvbSAnLi4vdXRpbGl0eS9tZXJnZVByb3BlcnR5LmpzJ1xuaW1wb3J0IHsgZ2V0TmVzdGVkT2JqZWN0IH0gZnJvbSAnLi4vdXRpbGl0eS9nZXROZXN0ZWRPYmplY3QuanMnXG5cbmV4cG9ydCBjb25zdCBuZXN0ZWRQcm9wZXJ0eURlbGVnYXRlZExvb2t1cEN1cnJpZWQgPSAoeyBiYXNlUHJvcGVydHkgfSkgPT4ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYmFzZVByb3BlcnR5KSkgYmFzZVByb3BlcnR5ID0gW2Jhc2VQcm9wZXJ0eV1cbiAgcmV0dXJuIGZ1bmN0aW9uKGltcGxlbWVudGF0aW9uS2V5OiBTdHJpbmcsIHJlY3Vyc2l2ZTogQm9vbGVhbiA9IGZhbHNlLCBjYWxsZXJDbGFzcyA9IHRoaXMpIHtcbiAgICBhc3NlcnQoaW1wbGVtZW50YXRpb25LZXksIGDigKIgaW1wbGVtZW50YXRpb25LZXkgbXVzdCBiZSBwYXNzZWQuYClcbiAgICByZXR1cm4gbmVzdGVkUHJvcGVydHlEZWxlZ2F0ZWRMb29rdXAoe1xuICAgICAgdGFyZ2V0OiBjYWxsZXJDbGFzcyxcbiAgICAgIHByb3BlcnR5UGF0aDogWy4uLmJhc2VQcm9wZXJ0eSwgaW1wbGVtZW50YXRpb25LZXldLFxuICAgICAgcmVjdXJzaXZlLFxuICAgIH0pXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG1lcmdlT3duTmVzdGVkUHJvcGVydHlDdXJyaWVkID0gKHsgcHJvcGVydHkgfSkgPT4ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcGVydHkpKSBwcm9wZXJ0eSA9IFtwcm9wZXJ0eV1cbiAgcmV0dXJuIGZ1bmN0aW9uKGltcGxlbWVudGF0aW9uOiBPYmplY3QpIHtcbiAgICByZXR1cm4gbWVyZ2VPd25OZXN0ZWRQcm9wZXJ0eSh7IHRhcmdldDogdGhpcywgcHJvcGVydHlQYXRoOiBwcm9wZXJ0eSwgdmFsdWU6IGltcGxlbWVudGF0aW9uIH0pXG4gIH1cbn1cblxuLy8gVGhlIGdlbmVyYXRvciBmdW5jdGlvbiB1c2VzIGEgcGF0dGVybiB0aGF0IGFsbG93cyB0byBoYW5kb3ZlciBjb250cm9sICh5aWVsZCB2YWx1ZXMpIGFuZCBwcm9wYWdhdGUgdG8gdGhlIHJlcXVlc3QgZnVuY3Rpb24gKHN3aXRjaCB0YXJnZXQgZnVuY3Rpb24pXG5leHBvcnQgY29uc3QgY3JlYXRlU3dpdGNoR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbih7XG4gIGZhbGxiYWNrUHJvcGVydHlQYXRoLFxuICBpbXBsZW1lbnRhdGlvbkdldHRlclByb3BlcnR5UGF0aCwgLy8gdGhlIGdldHRlciBmdW5jdGlvbiBmb3IgdGhlIGltcGxlbWVudGF0aW9uIHVzaW5nIGl0cyBrZXkuXG59KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShmYWxsYmFja1Byb3BlcnR5UGF0aCkpIGZhbGxiYWNrUHJvcGVydHlQYXRoID0gW2ZhbGxiYWNrUHJvcGVydHlQYXRoXVxuICBpZiAoIUFycmF5LmlzQXJyYXkoaW1wbGVtZW50YXRpb25HZXR0ZXJQcm9wZXJ0eVBhdGgpKSBpbXBsZW1lbnRhdGlvbkdldHRlclByb3BlcnR5UGF0aCA9IFtpbXBsZW1lbnRhdGlvbkdldHRlclByb3BlcnR5UGF0aF1cblxuICBsZXQgZ2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiooe1xuICAgIGltcGxlbWVudGF0aW9uS2V5LFxuICAgIC8qIExpa2UgdGhlIG5hdGl2ZSBKUyBiZWhhdmlvciBmb3IgYGNvbnN0cnVjdG9yYCBmdW5jdGlvbiB0aGF0IGNhbGxzIHRoZSBzdXBlciBjb25zdHJ1Y3RvciBhcyB3ZWxsIGluIHRoZSBjaGFpbi5cbiAgICAgIEZ1bmN0aW9ucyB1c2luZyByZWN1cnNpdmUgb3B0aW9uIG11c3QgZm9sbG93IHRoZSBmdW5jdGlvbiBkZWZpbml0aW9uIC0gIGZ1bmN0aW9uKGFyZ3VtZW50TGlzdDxPYmplY3Q+LCBwcmV2aW91c1Jlc3VsdDxhbnk+KVxuICAgICovXG4gICAgcmVjdXJzaXZlRGVsZWdhdGlvbkNoYWluRXhlY3V0aW9uID0gZmFsc2UsIC8vIEV4ZWN1dGUgYWxsIGZ1bmN0aW9ucyBpbiB0aGUgZGVsZWdhdGlvbiBjaGFpbiB0aGF0IG1hdGNoIHRoZSBgaW1wbGVtZW50YXRpb25LZXlgIHZhbHVlLiBlLmcuIHVzZSBpbml0aWFsaXphdGlvbiBmdW5jdGlvbiBmcm9tIGVhY2ggY2xhc3MgaW4gdGhlIHByb3RvdHlwZSBjaGFpbi5cbiAgICBjYWxsZXJDbGFzcyA9IHRoaXMsIC8vIHRoZSBjb25zdHJ1Y3RhYmxlIGNsYXNzIHRoYXQgaW5pdGlhdGVkIHRoZSBmdW5jdGlvbiBjYWxsLlxuICB9OiB7IGltcGxlbWVudGF0aW9uS2V5OiBTdHJpbmcgfSA9IHt9KSB7XG4gICAgY29uc3QgY29udHJvbEFyZyA9IGZ1bmN0aW9uLnNlbnQsXG4gICAgICBzaG91bGRIYW5kT3ZlciA9IGV4ZWN1dGlvbkNvbnRyb2wuc2hvdWxkSGFuZE92ZXIoY29udHJvbEFyZyksXG4gICAgICBzaG91bGRQcm9wYWdhdGUgPSBleGVjdXRpb25Db250cm9sLnNob3VsZFByb3BhZ2F0ZShjb250cm9sQXJnKVxuXG4gICAgaW1wbGVtZW50YXRpb25LZXkgfHw9IGdldE5lc3RlZE9iamVjdChjYWxsZXJDbGFzcywgZmFsbGJhY2tQcm9wZXJ0eVBhdGgpXG5cbiAgICBsZXQgaW1wbGVtZW50YXRpb246IE9iamVjdCB8IEFycmF5PE9iamVjdD4sIGxvb2t1cFJlc3VsdCAvLyBpbXBsZW1lbnRhdGlvbiBmdW5jdGlvbnMgdG8gZXhlY3V0ZVxuICAgIGxldCBpbXBsZW1lbnRhdGlvbkdldHRlciA9IGdldE5lc3RlZE9iamVjdChjYWxsZXJDbGFzcywgaW1wbGVtZW50YXRpb25HZXR0ZXJQcm9wZXJ0eVBhdGgpXG4gICAgaWYgKHJlY3Vyc2l2ZURlbGVnYXRpb25DaGFpbkV4ZWN1dGlvbikge1xuICAgICAgbG9va3VwUmVzdWx0ID0gY2FsbGVyQ2xhc3M6OmltcGxlbWVudGF0aW9uR2V0dGVyKGltcGxlbWVudGF0aW9uS2V5LCB0cnVlIC8qcmVjdXJzaXZlIGV4ZWN1dGlvbiBvZiBtdWx0aXBsZSBpbXBsZW1lbnRhdGlvbnMqLylcbiAgICAgIGFzc2VydChsb29rdXBSZXN1bHQgJiYgbG9va3VwUmVzdWx0Lmxlbmd0aCA+IDAsIGDigKIgTm8gaW1wbGVtZW50YXRpb24gY29uc3RydWN0b3IgZm91bmQgZm9yIGtleSAke2ltcGxlbWVudGF0aW9uS2V5LnRvU3RyaW5nKCl9YClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2luZ2xlIGltcGxlbWVudGF0aW9uXG4gICAgICBsb29rdXBSZXN1bHQgPSBjYWxsZXJDbGFzczo6aW1wbGVtZW50YXRpb25HZXR0ZXIoaW1wbGVtZW50YXRpb25LZXkpXG4gICAgICBhc3NlcnQobG9va3VwUmVzdWx0LCBg4oCiIE5vIGltcGxlbWVudGF0aW9uIGNvbnN0cnVjdG9yIGZvdW5kIGZvciBrZXkgJHsoaW1wbGVtZW50YXRpb25LZXkgJiYgaW1wbGVtZW50YXRpb25LZXkudG9TdHJpbmcoKSkgfHwgaW1wbGVtZW50YXRpb25LZXl9YClcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGxvb2t1cFJlc3VsdCkpIGxvb2t1cFJlc3VsdCA9IFtsb29rdXBSZXN1bHRdIC8vIGZvciBwcmV2ZW50aW5nIHNlcGFyYXRlIGNvZGUgZm9yIGV4ZWN1dGlvbi5cbiAgICBpbXBsZW1lbnRhdGlvbiA9IGxvb2t1cFJlc3VsdC5tYXAoKGZ1bmMsIGluZGV4KSA9PiB7XG4gICAgICByZXR1cm4geyBmdW5jOiBmdW5jLCBwYXNzVGhyb3VnaEFyZzoge30gLyoqIE5vdGU6IHN1cHBvcnRpbmcgYXJyYXkgYXJncyBpcyBwb3NzaWJsZSBidXQgYWRkcyBhZGRpdGlvbmFsIGNvbXBsZXhpdHkgKi8gfVxuICAgIH0pXG5cbiAgICBsZXQgcmVzdWx0ID0gbnVsbCAvLyBhY3RzIGFzIHByZXZpb3VzIHJlc3VsdCAoc2ltaWxhciB0byByZWR1Y2UgZnVuY3Rpb24gYnV0IGFsbG93cyB1c2FnZSBvZiBgeWllbGQqYCBrZXl3b3JkKVxuICAgIGZvciAobGV0IGluZGV4IGluIGltcGxlbWVudGF0aW9uKSB7XG4gICAgICAvLyBOT3RlOiBleGVjdXRpb24gc3RhcnRzIGZyb20gdGhlIGZpcnN0IG1hdGNoaW5nIGZ1bmN0aW9uIGluIHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gdGhlIGxhc3QgaS5lLiBmcm9tIGNsYXNzIGNhbGxlciB0byBkZWxlZ2F0ZWQgb2JqZWN0LiBUaGlzIGJlaGF2aW9yIGlzIHNpbWlsYXIgdG8gdGhlIG5hdGl2ZSBKUyBgY29uc3RydWN0b3JgIGV4ZWN1dGlvbiBiZWhhdmlvciBpbiBjbGFzcyBpbmhlcml0YW5jZS5cbiAgICAgIGlmIChzaG91bGRIYW5kT3ZlcikgaW1wbGVtZW50YXRpb25baW5kZXhdLnBhc3NUaHJvdWdoQXJnID0geWllbGQgaW1wbGVtZW50YXRpb25baW5kZXhdLnBhc3NUaHJvdWdoQXJnIC8vIGNsaWVudCBzaG91bGQgbWFuaXB1bGF0ZSBgaW1wbGVtZW50YXRpb24ucGFzc1Rocm91Z2hBcmdgIGZvciBlYWNoIGZ1bmN0aW9uIGluIHRoZSBjaGFpbi5cbiAgICAgIGxldCBjdXJyZW50UmVzdWx0ID0gY2FsbGVyQ2xhc3M6OmltcGxlbWVudGF0aW9uW2luZGV4XS5mdW5jKGltcGxlbWVudGF0aW9uW2luZGV4XS5wYXNzVGhyb3VnaEFyZywgcmVzdWx0IC8qcGlwZSBwcmV2aW91cyByZXN1bHQgYXMgc2Vjb25kIHBhcmFtdGVyKi8pXG5cbiAgICAgIC8vIERlYWwgd2l0aCBkaWZmZXJlbnQgZnVuY3Rpb24gdHlwZXMgLSByZWRpcmVjdCBjb25zdHJ1Y3QgdG8gcGFydGljdWxhciBpbXBsZW1lbnRhdGlvbiB1c2luZyBzcGVjaWZpYyBleGVjdXRpb24gZGVwZW5kaW5nIG9mIGZ1bmN0aW9uIHR5cGUuXG4gICAgICBpZiAoaXNHZW5lcmF0b3JGdW5jdGlvbihpbXBsZW1lbnRhdGlvbltpbmRleF0uZnVuYykpIHtcbiAgICAgICAgaWYgKHNob3VsZFByb3BhZ2F0ZSkge1xuICAgICAgICAgIC8vIHVzaW5nIGB5aWVsZCpgIHJlcXVpcmVzIHRoZSBjbGllbnQgdG8gbWFrZSBhbiBhZGRpdGlvbmFsIGVtcHR5IGNhbGwgYW5kIGFkZHMsIGFuZCBtYWtlcyBkaWZmZXJlbnRpYXRpbmcgeWllbGRzIG1vcmUgZGlmZmljdWx0LlxuICAgICAgICAgIC8vVE9ETzogVGVzdCBmb3IgcHJvcGVyIGNsaWVudCBhYmlsaXR5IHRvIGludGVyYWN0IHdpdGggdGhpcyB1c2VjYXNlIChgeWllbGQqYClcbiAgICAgICAgICByZXN1bHQgPSB5aWVsZCogY3VycmVudFJlc3VsdFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IGN1cnJlbnRSZXN1bHQgfD4gKGcgPT4gZy5uZXh0KCdjb21wbGV0ZScpLnZhbHVlKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZWd1bGFyIGZ1bmN0aW9uIChub24tZ2VuZXJhdG9yKVxuICAgICAgICByZXN1bHQgPSBjdXJyZW50UmVzdWx0XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgcmV0dXJuIGdlbmVyYXRvckZ1bmN0aW9uXG59XG4iXX0=