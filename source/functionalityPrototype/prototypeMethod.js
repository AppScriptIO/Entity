"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports, "__esModule", { value: true });exports.createSwitchGeneratorFunction = exports.mergeOwnNestedPropertyCurried = exports.nestedPropertyDelegatedLookupCurried = void 0;var _skipFirstGeneratorNext2 = _interopRequireDefault(require("@babel/runtime/helpers/skipFirstGeneratorNext"));var _assert = _interopRequireDefault(require("assert"));
var _isGeneratorFunction = require("../utility/isGeneratorFunction.js");
var _generatorExecutionControl = require("../utility/generatorExecutionControl.js");
var _delegatedLookup = require("../utility/delegatedLookup.js");
var _mergeProperty = require("../utility/mergeProperty.js");
var _getNestedObject = require("../utility/getNestedObject.js");

const nestedPropertyDelegatedLookupCurried = ({ baseProperty }) => {
  if (!Array.isArray(baseProperty)) baseProperty = [baseProperty];
  return function (implementationKey, recursive = false, callerClass = this) {
    (0, _assert.default)(implementationKey, `• implementationKey must be passed, cannot be undefined.`);
    return (0, _delegatedLookup.nestedPropertyDelegatedLookup)({
      target: callerClass,
      propertyPath: [...baseProperty, implementationKey],
      recursive });

  };
};exports.nestedPropertyDelegatedLookupCurried = nestedPropertyDelegatedLookupCurried;

const mergeOwnNestedPropertyCurried = ({ property }) => {
  if (!Array.isArray(property)) property = [property];
  return function (implementation) {
    return (0, _mergeProperty.mergeOwnNestedProperty)({ target: this, propertyPath: property, value: implementation });
  };
};exports.mergeOwnNestedPropertyCurried = mergeOwnNestedPropertyCurried;


const createSwitchGeneratorFunction = function ({
  fallbackPropertyPath,
  implementationGetterPropertyPath })
{
  if (!Array.isArray(fallbackPropertyPath)) fallbackPropertyPath = [fallbackPropertyPath];
  if (!Array.isArray(implementationGetterPropertyPath)) implementationGetterPropertyPath = [implementationGetterPropertyPath];

  let generatorFunction = (function () {let _ref = function* ({
      implementationKey,



      recursiveDelegationChainExecution = false,
      callerClass = this } =
    {}) {let _functionSent = yield;
      const controlArg = _functionSent,
      shouldHandOver = _generatorExecutionControl.executionControl.shouldHandOver(controlArg),
      shouldPropagate = _generatorExecutionControl.executionControl.shouldPropagate(controlArg);

      implementationKey || (implementationKey = (0, _getNestedObject.getNestedObject)(callerClass, fallbackPropertyPath));

      let implementation, lookupResult;
      let implementationGetter = (0, _getNestedObject.getNestedObject)(callerClass, implementationGetterPropertyPath);
      if (recursiveDelegationChainExecution) {var _context;
        lookupResult = (_context = callerClass, implementationGetter).call(_context, implementationKey, true);
        (0, _assert.default)(lookupResult && lookupResult.length > 0, `• No implementation constructor found for key ${implementationKey.toString()}`);
      } else {var _context2;

        lookupResult = (_context2 = callerClass, implementationGetter).call(_context2, implementationKey);
        (0, _assert.default)(lookupResult, `• No implementation constructor found for key ${implementationKey && implementationKey.toString() || implementationKey}`);
      }
      if (!Array.isArray(lookupResult)) lookupResult = [lookupResult];
      implementation = lookupResult.map((func, index) => {
        return { func: func, passThroughArg: {} };
      });

      let result = null;
      for (let index in implementation) {var _context3;

        if (shouldHandOver) implementation[index].passThroughArg = _functionSent = yield implementation[index].passThroughArg;
        let currentResult = (_context3 = callerClass, implementation[index].func).call(_context3, implementation[index].passThroughArg, result);


        if ((0, _isGeneratorFunction.isGeneratorFunction)(implementation[index].func)) {
          if (shouldPropagate) {


            result = _functionSent = yield* currentResult;
          } else {var _g;
            result = (_g = currentResult, _g.next('complete').value);
          }
        } else {

          result = currentResult;
        }
      }

      return result;
    },_ref2 = (0, _skipFirstGeneratorNext2.default)(_ref);return new Proxy(_ref, { apply(target, thisArgument, argumentsList) {return Reflect.apply(_ref2, thisArgument, argumentsList);} });})();





  return new Proxy(generatorFunction, {
    apply(target, thisArg, argumentList) {
      let iterator = Reflect.apply(target, thisArg, argumentList);
      return new Proxy(function () {}, {
        apply(_, thisArg, _argumentList) {var _iterator;
          return _iterator =

          iterator, (
          g => {
            g.next('intermittent');

            let iterator;
            do {
              iterator = g.next(..._argumentList);
            } while (!iterator.done);
            return iterator.value;
          })(_iterator);

        },
        get(_, property, receiver) {
          let value = Reflect.get(iterator, property, receiver);
          if (property == 'next') return value.bind(iterator);
          return value;
        } });

    } });

};exports.createSwitchGeneratorFunction = createSwitchGeneratorFunction;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NvdXJjZS9mdW5jdGlvbmFsaXR5UHJvdG90eXBlL3Byb3RvdHlwZU1ldGhvZC5qcyJdLCJuYW1lcyI6WyJuZXN0ZWRQcm9wZXJ0eURlbGVnYXRlZExvb2t1cEN1cnJpZWQiLCJiYXNlUHJvcGVydHkiLCJBcnJheSIsImlzQXJyYXkiLCJpbXBsZW1lbnRhdGlvbktleSIsInJlY3Vyc2l2ZSIsImNhbGxlckNsYXNzIiwidGFyZ2V0IiwicHJvcGVydHlQYXRoIiwibWVyZ2VPd25OZXN0ZWRQcm9wZXJ0eUN1cnJpZWQiLCJwcm9wZXJ0eSIsImltcGxlbWVudGF0aW9uIiwidmFsdWUiLCJjcmVhdGVTd2l0Y2hHZW5lcmF0b3JGdW5jdGlvbiIsImZhbGxiYWNrUHJvcGVydHlQYXRoIiwiaW1wbGVtZW50YXRpb25HZXR0ZXJQcm9wZXJ0eVBhdGgiLCJnZW5lcmF0b3JGdW5jdGlvbiIsInJlY3Vyc2l2ZURlbGVnYXRpb25DaGFpbkV4ZWN1dGlvbiIsImNvbnRyb2xBcmciLCJzaG91bGRIYW5kT3ZlciIsImV4ZWN1dGlvbkNvbnRyb2wiLCJzaG91bGRQcm9wYWdhdGUiLCJsb29rdXBSZXN1bHQiLCJpbXBsZW1lbnRhdGlvbkdldHRlciIsImxlbmd0aCIsInRvU3RyaW5nIiwibWFwIiwiZnVuYyIsImluZGV4IiwicGFzc1Rocm91Z2hBcmciLCJyZXN1bHQiLCJjdXJyZW50UmVzdWx0IiwiZyIsIm5leHQiLCJQcm94eSIsImFwcGx5IiwidGhpc0FyZyIsImFyZ3VtZW50TGlzdCIsIml0ZXJhdG9yIiwiUmVmbGVjdCIsIl8iLCJfYXJndW1lbnRMaXN0IiwiZG9uZSIsImdldCIsInJlY2VpdmVyIl0sIm1hcHBpbmdzIjoic1pBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLE1BQU1BLG9DQUFvQyxHQUFHLENBQUMsRUFBRUMsWUFBRixFQUFELEtBQXNCO0FBQ3hFLE1BQUksQ0FBQ0MsS0FBSyxDQUFDQyxPQUFOLENBQWNGLFlBQWQsQ0FBTCxF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QWY7QUFDQSxhQUFPLElBQUlILEtBQUosQ0FBVSxZQUFXLENBQUUsQ0FBdkIsRUFBcUU7QUFDMUVDLFFBQUFBLEtBQUssQ0FBQ0ssQ0FBRCxFQUFJSixPQUFKLEVBQWFLLGFBQWIsRUFBNEI7QUFDL0I7O0FBRUVILFVBQUFBLFFBRkY7QUFHTU4sVUFBQUEsQ0FBQyxJQUFJO0FBQ1BBLFlBQUFBLENBQUMsQ0FBQ0MsSUFBRixDQUFPLGNBQVA7O0FBRUEsZ0JBQUlLLFFBQUo7QUFDQSxlQUFHO0FBQ0RBLGNBQUFBLFFBQVEsR0FBR04sQ0FBQyxDQUFDQyxJQUFGLENBQU8sR0FBR1EsYUFBVixDQUFYO0FBQ0QsYUFGRCxRQUVTLENBQUNILFFBQVEsQ0FBQ0ksSUFGbkI7QUFHQSxtQkFBT0osUUFBUSxDQUFDMUIsS0FBaEI7QUFDRCxXQVhIOztBQWFELFNBZnlFO0FBZ0IxRStCLFFBQUFBLEdBQUcsQ0FBQ0gsQ0FBRCxFQUFJOUIsUUFBSixFQUFja0MsUUFBZCxFQUF3QjtBQUN6QixjQUFJaEMsS0FBSyxHQUFHMkIsT0FBTyxDQUFDSSxHQUFSLENBQVlMLFFBQVosRUFBc0I1QixRQUF0QixFQUFnQ2tDLFFBQWhDLENBQVo7QUFDQSxjQUFJbEMsUUFBUSxJQUFJLE1BQWhCLEVBQXdCLE9BQWlCRSxLQUFqQixNQUFPMEIsUUFBUDtBQUN4QixpQkFBTzFCLEtBQVA7QUFDRCxTQXBCeUUsRUFBckUsQ0FBUDs7QUFzQkQsS0F6QmlDLEVBQTdCLENBQVA7O0FBMkJELENBM0ZNLEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCdcbmltcG9ydCB7IGlzR2VuZXJhdG9yRnVuY3Rpb24gfSBmcm9tICcuLi91dGlsaXR5L2lzR2VuZXJhdG9yRnVuY3Rpb24uanMnXG5pbXBvcnQgeyBleGVjdXRpb25Db250cm9sIH0gZnJvbSAnLi4vdXRpbGl0eS9nZW5lcmF0b3JFeGVjdXRpb25Db250cm9sLmpzJ1xuaW1wb3J0IHsgbmVzdGVkUHJvcGVydHlEZWxlZ2F0ZWRMb29rdXAgfSBmcm9tICcuLi91dGlsaXR5L2RlbGVnYXRlZExvb2t1cC5qcydcbmltcG9ydCB7IG1lcmdlT3duTmVzdGVkUHJvcGVydHkgfSBmcm9tICcuLi91dGlsaXR5L21lcmdlUHJvcGVydHkuanMnXG5pbXBvcnQgeyBnZXROZXN0ZWRPYmplY3QgfSBmcm9tICcuLi91dGlsaXR5L2dldE5lc3RlZE9iamVjdC5qcydcblxuZXhwb3J0IGNvbnN0IG5lc3RlZFByb3BlcnR5RGVsZWdhdGVkTG9va3VwQ3VycmllZCA9ICh7IGJhc2VQcm9wZXJ0eSB9KSA9PiB7XG4gIGlmICghQXJyYXkuaXNBcnJheShiYXNlUHJvcGVydHkpKSBiYXNlUHJvcGVydHkgPSBbYmFzZVByb3BlcnR5XVxuICByZXR1cm4gZnVuY3Rpb24oaW1wbGVtZW50YXRpb25LZXk6IFN0cmluZywgcmVjdXJzaXZlOiBCb29sZWFuID0gZmFsc2UsIGNhbGxlckNsYXNzID0gdGhpcykge1xuICAgIGFzc2VydChpbXBsZW1lbnRhdGlvbktleSwgYOKAoiBpbXBsZW1lbnRhdGlvbktleSBtdXN0IGJlIHBhc3NlZCwgY2Fubm90IGJlIHVuZGVmaW5lZC5gKVxuICAgIHJldHVybiBuZXN0ZWRQcm9wZXJ0eURlbGVnYXRlZExvb2t1cCh7XG4gICAgICB0YXJnZXQ6IGNhbGxlckNsYXNzLFxuICAgICAgcHJvcGVydHlQYXRoOiBbLi4uYmFzZVByb3BlcnR5LCBpbXBsZW1lbnRhdGlvbktleV0sXG4gICAgICByZWN1cnNpdmUsXG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbWVyZ2VPd25OZXN0ZWRQcm9wZXJ0eUN1cnJpZWQgPSAoeyBwcm9wZXJ0eSB9KSA9PiB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwcm9wZXJ0eSkpIHByb3BlcnR5ID0gW3Byb3BlcnR5XVxuICByZXR1cm4gZnVuY3Rpb24oaW1wbGVtZW50YXRpb246IE9iamVjdCkge1xuICAgIHJldHVybiBtZXJnZU93bk5lc3RlZFByb3BlcnR5KHsgdGFyZ2V0OiB0aGlzLCBwcm9wZXJ0eVBhdGg6IHByb3BlcnR5LCB2YWx1ZTogaW1wbGVtZW50YXRpb24gfSlcbiAgfVxufVxuXG4vLyBUaGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIHVzZXMgYSBwYXR0ZXJuIHRoYXQgYWxsb3dzIHRvIGhhbmRvdmVyIGNvbnRyb2wgKHlpZWxkIHZhbHVlcykgYW5kIHByb3BhZ2F0ZSB0byB0aGUgcmVxdWVzdCBmdW5jdGlvbiAoc3dpdGNoIHRhcmdldCBmdW5jdGlvbilcbmV4cG9ydCBjb25zdCBjcmVhdGVTd2l0Y2hHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKHtcbiAgZmFsbGJhY2tQcm9wZXJ0eVBhdGgsXG4gIGltcGxlbWVudGF0aW9uR2V0dGVyUHJvcGVydHlQYXRoLCAvLyB0aGUgZ2V0dGVyIGZ1bmN0aW9uIGZvciB0aGUgaW1wbGVtZW50YXRpb24gdXNpbmcgaXRzIGtleS5cbn0pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGZhbGxiYWNrUHJvcGVydHlQYXRoKSkgZmFsbGJhY2tQcm9wZXJ0eVBhdGggPSBbZmFsbGJhY2tQcm9wZXJ0eVBhdGhdXG4gIGlmICghQXJyYXkuaXNBcnJheShpbXBsZW1lbnRhdGlvbkdldHRlclByb3BlcnR5UGF0aCkpIGltcGxlbWVudGF0aW9uR2V0dGVyUHJvcGVydHlQYXRoID0gW2ltcGxlbWVudGF0aW9uR2V0dGVyUHJvcGVydHlQYXRoXVxuXG4gIGxldCBnZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKih7XG4gICAgaW1wbGVtZW50YXRpb25LZXksXG4gICAgLyogTGlrZSB0aGUgbmF0aXZlIEpTIGJlaGF2aW9yIGZvciBgY29uc3RydWN0b3JgIGZ1bmN0aW9uIHRoYXQgY2FsbHMgdGhlIHN1cGVyIGNvbnN0cnVjdG9yIGFzIHdlbGwgaW4gdGhlIGNoYWluLlxuICAgICAgRnVuY3Rpb25zIHVzaW5nIHJlY3Vyc2l2ZSBvcHRpb24gbXVzdCBmb2xsb3cgdGhlIGZ1bmN0aW9uIGRlZmluaXRpb24gLSAgZnVuY3Rpb24oYXJndW1lbnRMaXN0PE9iamVjdD4sIHByZXZpb3VzUmVzdWx0PGFueT4pXG4gICAgKi9cbiAgICByZWN1cnNpdmVEZWxlZ2F0aW9uQ2hhaW5FeGVjdXRpb24gPSBmYWxzZSwgLy8gRXhlY3V0ZSBhbGwgZnVuY3Rpb25zIGluIHRoZSBkZWxlZ2F0aW9uIGNoYWluIHRoYXQgbWF0Y2ggdGhlIGBpbXBsZW1lbnRhdGlvbktleWAgdmFsdWUuIGUuZy4gdXNlIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9uIGZyb20gZWFjaCBjbGFzcyBpbiB0aGUgcHJvdG90eXBlIGNoYWluLlxuICAgIGNhbGxlckNsYXNzID0gdGhpcywgLy8gdGhlIGNvbnN0cnVjdGFibGUgY2xhc3MgdGhhdCBpbml0aWF0ZWQgdGhlIGZ1bmN0aW9uIGNhbGwuXG4gIH06IHsgaW1wbGVtZW50YXRpb25LZXk6IFN0cmluZyB9ID0ge30pIHtcbiAgICBjb25zdCBjb250cm9sQXJnID0gZnVuY3Rpb24uc2VudCxcbiAgICAgIHNob3VsZEhhbmRPdmVyID0gZXhlY3V0aW9uQ29udHJvbC5zaG91bGRIYW5kT3Zlcihjb250cm9sQXJnKSxcbiAgICAgIHNob3VsZFByb3BhZ2F0ZSA9IGV4ZWN1dGlvbkNvbnRyb2wuc2hvdWxkUHJvcGFnYXRlKGNvbnRyb2xBcmcpXG5cbiAgICBpbXBsZW1lbnRhdGlvbktleSB8fD0gZ2V0TmVzdGVkT2JqZWN0KGNhbGxlckNsYXNzLCBmYWxsYmFja1Byb3BlcnR5UGF0aClcblxuICAgIGxldCBpbXBsZW1lbnRhdGlvbjogT2JqZWN0IHwgQXJyYXk8T2JqZWN0PiwgbG9va3VwUmVzdWx0IC8vIGltcGxlbWVudGF0aW9uIGZ1bmN0aW9ucyB0byBleGVjdXRlXG4gICAgbGV0IGltcGxlbWVudGF0aW9uR2V0dGVyID0gZ2V0TmVzdGVkT2JqZWN0KGNhbGxlckNsYXNzLCBpbXBsZW1lbnRhdGlvbkdldHRlclByb3BlcnR5UGF0aClcbiAgICBpZiAocmVjdXJzaXZlRGVsZWdhdGlvbkNoYWluRXhlY3V0aW9uKSB7XG4gICAgICBsb29rdXBSZXN1bHQgPSBjYWxsZXJDbGFzczo6aW1wbGVtZW50YXRpb25HZXR0ZXIoaW1wbGVtZW50YXRpb25LZXksIHRydWUgLypyZWN1cnNpdmUgZXhlY3V0aW9uIG9mIG11bHRpcGxlIGltcGxlbWVudGF0aW9ucyovKVxuICAgICAgYXNzZXJ0KGxvb2t1cFJlc3VsdCAmJiBsb29rdXBSZXN1bHQubGVuZ3RoID4gMCwgYOKAoiBObyBpbXBsZW1lbnRhdGlvbiBjb25zdHJ1Y3RvciBmb3VuZCBmb3Iga2V5ICR7aW1wbGVtZW50YXRpb25LZXkudG9TdHJpbmcoKX1gKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzaW5nbGUgaW1wbGVtZW50YXRpb25cbiAgICAgIGxvb2t1cFJlc3VsdCA9IGNhbGxlckNsYXNzOjppbXBsZW1lbnRhdGlvbkdldHRlcihpbXBsZW1lbnRhdGlvbktleSlcbiAgICAgIGFzc2VydChsb29rdXBSZXN1bHQsIGDigKIgTm8gaW1wbGVtZW50YXRpb24gY29uc3RydWN0b3IgZm91bmQgZm9yIGtleSAkeyhpbXBsZW1lbnRhdGlvbktleSAmJiBpbXBsZW1lbnRhdGlvbktleS50b1N0cmluZygpKSB8fCBpbXBsZW1lbnRhdGlvbktleX1gKVxuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobG9va3VwUmVzdWx0KSkgbG9va3VwUmVzdWx0ID0gW2xvb2t1cFJlc3VsdF0gLy8gZm9yIHByZXZlbnRpbmcgc2VwYXJhdGUgY29kZSBmb3IgZXhlY3V0aW9uLlxuICAgIGltcGxlbWVudGF0aW9uID0gbG9va3VwUmVzdWx0Lm1hcCgoZnVuYywgaW5kZXgpID0+IHtcbiAgICAgIHJldHVybiB7IGZ1bmM6IGZ1bmMsIHBhc3NUaHJvdWdoQXJnOiB7fSAvKiogTm90ZTogc3VwcG9ydGluZyBhcnJheSBhcmdzIGlzIHBvc3NpYmxlIGJ1dCBhZGRzIGFkZGl0aW9uYWwgY29tcGxleGl0eSAqLyB9XG4gICAgfSlcblxuICAgIGxldCByZXN1bHQgPSBudWxsIC8vIGFjdHMgYXMgcHJldmlvdXMgcmVzdWx0IChzaW1pbGFyIHRvIHJlZHVjZSBmdW5jdGlvbiBidXQgYWxsb3dzIHVzYWdlIG9mIGB5aWVsZCpgIGtleXdvcmQpXG4gICAgZm9yIChsZXQgaW5kZXggaW4gaW1wbGVtZW50YXRpb24pIHtcbiAgICAgIC8vIE5PdGU6IGV4ZWN1dGlvbiBzdGFydHMgZnJvbSB0aGUgZmlyc3QgbWF0Y2hpbmcgZnVuY3Rpb24gaW4gdGhlIHByb3RvdHlwZSBjaGFpbiB0byB0aGUgbGFzdCBpLmUuIGZyb20gY2xhc3MgY2FsbGVyIHRvIGRlbGVnYXRlZCBvYmplY3QuIFRoaXMgYmVoYXZpb3IgaXMgc2ltaWxhciB0byB0aGUgbmF0aXZlIEpTIGBjb25zdHJ1Y3RvcmAgZXhlY3V0aW9uIGJlaGF2aW9yIGluIGNsYXNzIGluaGVyaXRhbmNlLlxuICAgICAgaWYgKHNob3VsZEhhbmRPdmVyKSBpbXBsZW1lbnRhdGlvbltpbmRleF0ucGFzc1Rocm91Z2hBcmcgPSB5aWVsZCBpbXBsZW1lbnRhdGlvbltpbmRleF0ucGFzc1Rocm91Z2hBcmcgLy8gY2xpZW50IHNob3VsZCBtYW5pcHVsYXRlIGBpbXBsZW1lbnRhdGlvbi5wYXNzVGhyb3VnaEFyZ2AgZm9yIGVhY2ggZnVuY3Rpb24gaW4gdGhlIGNoYWluLlxuICAgICAgbGV0IGN1cnJlbnRSZXN1bHQgPSBjYWxsZXJDbGFzczo6aW1wbGVtZW50YXRpb25baW5kZXhdLmZ1bmMoaW1wbGVtZW50YXRpb25baW5kZXhdLnBhc3NUaHJvdWdoQXJnLCByZXN1bHQgLypwaXBlIHByZXZpb3VzIHJlc3VsdCBhcyBzZWNvbmQgcGFyYW10ZXIqLylcblxuICAgICAgLy8gRGVhbCB3aXRoIGRpZmZlcmVudCBmdW5jdGlvbiB0eXBlcyAtIHJlZGlyZWN0IGNvbnN0cnVjdCB0byBwYXJ0aWN1bGFyIGltcGxlbWVudGF0aW9uIHVzaW5nIHNwZWNpZmljIGV4ZWN1dGlvbiBkZXBlbmRpbmcgb2YgZnVuY3Rpb24gdHlwZS5cbiAgICAgIGlmIChpc0dlbmVyYXRvckZ1bmN0aW9uKGltcGxlbWVudGF0aW9uW2luZGV4XS5mdW5jKSkge1xuICAgICAgICBpZiAoc2hvdWxkUHJvcGFnYXRlKSB7XG4gICAgICAgICAgLy8gdXNpbmcgYHlpZWxkKmAgcmVxdWlyZXMgdGhlIGNsaWVudCB0byBtYWtlIGFuIGFkZGl0aW9uYWwgZW1wdHkgY2FsbCBhbmQgYWRkcywgYW5kIG1ha2VzIGRpZmZlcmVudGlhdGluZyB5aWVsZHMgbW9yZSBkaWZmaWN1bHQuXG4gICAgICAgICAgLy9UT0RPOiBUZXN0IGZvciBwcm9wZXIgY2xpZW50IGFiaWxpdHkgdG8gaW50ZXJhY3Qgd2l0aCB0aGlzIHVzZWNhc2UgKGB5aWVsZCpgKVxuICAgICAgICAgIHJlc3VsdCA9IHlpZWxkKiBjdXJyZW50UmVzdWx0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gY3VycmVudFJlc3VsdCB8PiAoZyA9PiBnLm5leHQoJ2NvbXBsZXRlJykudmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJldHVybiB0aGUgcmVndWxhciBmdW5jdGlvbiAobm9uLWdlbmVyYXRvcilcbiAgICAgICAgcmVzdWx0ID0gY3VycmVudFJlc3VsdFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgaW50ZXJmYWNlIGJlaGF2aW9yIGZvciBub24gZ2VuZXJhdG9yIHRhcmdldHMgLSBleHBvc2UgZ2VuZXJhdG9yIGFzIHJlZ3VsYXIgZnVuY3Rpb24gZm9yIHF1aWNrIG5vbiBwcm9wYWdhdGluZyBjYWxscy5cbiAgICogV2hlbiB0aGUgZ2VuZXJhdG9yJ3MgaXRlcmF0b3IgaXMgY2FsbGVkIHRoZSBjb25zdHJ1Y3QgdHJhcCB3aWxsIGl0ZXJhdGUgb3ZlciBpdCBhbmQgcmV0dXJuIHRoZSByZXN1bHQuXG4gICAqKi9cbiAgcmV0dXJuIG5ldyBQcm94eShnZW5lcmF0b3JGdW5jdGlvbiwge1xuICAgIGFwcGx5KHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRMaXN0KSB7XG4gICAgICBsZXQgaXRlcmF0b3IgPSBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRMaXN0KVxuICAgICAgcmV0dXJuIG5ldyBQcm94eShmdW5jdGlvbigpIHt9IC8qYWxsb3cgbm9uIGZ1bmN0aW9uIHRvIHNldCBhcHBseSBoYW5kbGVyKi8sIHtcbiAgICAgICAgYXBwbHkoXywgdGhpc0FyZywgX2FyZ3VtZW50TGlzdCkge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAvLyBleGVjdXRlIGl0ZXJhdG9yIHRpbGwgdGhlIGVuZC5cbiAgICAgICAgICAgIGl0ZXJhdG9yXG4gICAgICAgICAgICB8PiAoZyA9PiB7XG4gICAgICAgICAgICAgIGcubmV4dCgnaW50ZXJtaXR0ZW50JylcbiAgICAgICAgICAgICAgLy8gcGFzcyB0byBhbGwgaW1wbGVtZW5hdGF0aW9ucyB0aGUgc2FtZSBhcmd1bWVudFxuICAgICAgICAgICAgICBsZXQgaXRlcmF0b3JcbiAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gZy5uZXh0KC4uLl9hcmd1bWVudExpc3QpXG4gICAgICAgICAgICAgIH0gd2hpbGUgKCFpdGVyYXRvci5kb25lKVxuICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3IudmFsdWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICB9LFxuICAgICAgICBnZXQoXywgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gUmVmbGVjdC5nZXQoaXRlcmF0b3IsIHByb3BlcnR5LCByZWNlaXZlcilcbiAgICAgICAgICBpZiAocHJvcGVydHkgPT0gJ25leHQnKSByZXR1cm4gaXRlcmF0b3I6OnZhbHVlIC8vIGJpbmQgdGhlIG9yaWdpbmFsIHRhcmdldCBpdGVyYXRvciB0byBwcmV2ZW50IGFuZCBlcnJvciBhcyB0aGUgbmF0aXZlIGdlbmVyYXRvciBpbXBsZW1lbnRhdGlvbiBjaGVja3MgdGhlIHRhcmdldCBleGVjdXRpbmcgJ25leHQnIGZ1bmN0aW9uLlxuICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9LFxuICB9KVxufVxuIl19