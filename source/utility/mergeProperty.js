"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports, "__esModule", { value: true });exports.mergeArrayWithObjectItem = exports.mergeNonexistentProperties = exports.mergeOwnNestedProperty = void 0;var _assert = _interopRequireDefault(require("assert"));
const hasOwnProperty = Object.prototype.hasOwnProperty;


const mergeOwnNestedProperty = ({ target, propertyPath, value }) => {
  (0, _assert.default)(propertyPath, 'â€¢ `propertyPath` must be passed.');

  if (!Array.isArray(propertyPath)) propertyPath = [propertyPath];
  let targetProperty = target;
  for (let index in propertyPath) {
    if (!hasOwnProperty.call(targetProperty, propertyPath[index])) {

      Object.defineProperty(targetProperty, propertyPath[index], { enumerable: true, writable: true, value: {} });
    }
    targetProperty = targetProperty[propertyPath[index]];
  }
  Object.assign(targetProperty, value);
  return target;
};exports.mergeOwnNestedProperty = mergeOwnNestedProperty;


const mergeNonexistentProperties = (targetObject, defaultValue) => {

  let propertyKey = [...Object.getOwnPropertySymbols(defaultValue), ...Object.getOwnPropertyNames(defaultValue)];
  let propertyDescriptor = Object.getOwnPropertyDescriptors(defaultValue);
  propertyKey.forEach(key => {
    if (!hasOwnProperty.call(targetObject, key)) Object.defineProperty(targetObject, key, propertyDescriptor[key]);
  });
};exports.mergeNonexistentProperties = mergeNonexistentProperties;


const mergeArrayWithObjectItem = ({ listTarget, listDefault }) => {

  for (let index in listTarget) {
    if (typeof listTarget[index] == 'object' && typeof listDefault[index] == 'object') listTarget[index] = Object.assign(listDefault[index], listTarget[index]);
    listTarget[index] || (listTarget[index] = listDefault[index]);
  }
};exports.mergeArrayWithObjectItem = mergeArrayWithObjectItem;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NvdXJjZS91dGlsaXR5L21lcmdlUHJvcGVydHkuanMiXSwibmFtZXMiOlsiaGFzT3duUHJvcGVydHkiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJtZXJnZU93bk5lc3RlZFByb3BlcnR5IiwidGFyZ2V0IiwicHJvcGVydHlQYXRoIiwidmFsdWUiLCJBcnJheSIsImlzQXJyYXkiLCJ0YXJnZXRQcm9wZXJ0eSIsImluZGV4IiwiY2FsbCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiYXNzaWduIiwibWVyZ2VOb25leGlzdGVudFByb3BlcnRpZXMiLCJ0YXJnZXRPYmplY3QiLCJkZWZhdWx0VmFsdWUiLCJwcm9wZXJ0eUtleSIsImdldE93blByb3BlcnR5U3ltYm9scyIsImdldE93blByb3BlcnR5TmFtZXMiLCJwcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZm9yRWFjaCIsImtleSIsIm1lcmdlQXJyYXlXaXRoT2JqZWN0SXRlbSIsImxpc3RUYXJnZXQiLCJsaXN0RGVmYXVsdCJdLCJtYXBwaW5ncyI6ImdSQUFBO0FBQ0EsTUFBTUEsY0FBYyxHQUFHQyxNQUFNLENBQUNDLFNBQVAsQ0FBaUJGLGNBQXhDOzs7QUFHTyxNQUFNRyxzQkFBc0IsR0FBRyxDQUFDLEVBQUVDLE1BQUYsRUFBVUMsWUFBVixFQUF3QkMsS0FBeEIsRUFBRCxLQUF5RjtBQUM3SCx1QkFBT0QsWUFBUCxFQUFxQixrQ0FBckI7O0FBRUEsTUFBSSxDQUFDRSxLQUFLLENBQUNDLE9BQU4sQ0FBY0gsWUFBZCxDQUFMLEVBQWtDQSxZQUFZLEdBQUcsQ0FBQ0EsWUFBRCxDQUFmO0FBQ2xDLE1BQUlJLGNBQWMsR0FBR0wsTUFBckI7QUFDQSxPQUFLLElBQUlNLEtBQVQsSUFBa0JMLFlBQWxCLEVBQWdDO0FBQzlCLFFBQUksQ0FBQ0wsY0FBYyxDQUFDVyxJQUFmLENBQW9CRixjQUFwQixFQUFvQ0osWUFBWSxDQUFDSyxLQUFELENBQWhELENBQUwsRUFBK0Q7O0FBRTdEVCxNQUFBQSxNQUFNLENBQUNXLGNBQVAsQ0FBc0JILGNBQXRCLEVBQXNDSixZQUFZLENBQUNLLEtBQUQsQ0FBbEQsRUFBMkQsRUFBRUcsVUFBVSxFQUFFLElBQWQsRUFBb0JDLFFBQVEsRUFBRSxJQUE5QixFQUFvQ1IsS0FBSyxFQUFFLEVBQTNDLEVBQTNEO0FBQ0Q7QUFDREcsSUFBQUEsY0FBYyxHQUFHQSxjQUFjLENBQUNKLFlBQVksQ0FBQ0ssS0FBRCxDQUFiLENBQS9CO0FBQ0Q7QUFDRFQsRUFBQUEsTUFBTSxDQUFDYyxNQUFQLENBQWNOLGNBQWQsRUFBOEJILEtBQTlCO0FBQ0EsU0FBT0YsTUFBUDtBQUNELENBZE0sQzs7O0FBaUJBLE1BQU1ZLDBCQUEwQixHQUFHLENBQUNDLFlBQUQsRUFBZUMsWUFBZixLQUF3Qzs7QUFFaEYsTUFBSUMsV0FBVyxHQUFHLENBQUMsR0FBR2xCLE1BQU0sQ0FBQ21CLHFCQUFQLENBQTZCRixZQUE3QixDQUFKLEVBQWdELEdBQUdqQixNQUFNLENBQUNvQixtQkFBUCxDQUEyQkgsWUFBM0IsQ0FBbkQsQ0FBbEI7QUFDQSxNQUFJSSxrQkFBa0IsR0FBR3JCLE1BQU0sQ0FBQ3NCLHlCQUFQLENBQWlDTCxZQUFqQyxDQUF6QjtBQUNBQyxFQUFBQSxXQUFXLENBQUNLLE9BQVosQ0FBb0JDLEdBQUcsSUFBSTtBQUN6QixRQUFJLENBQUN6QixjQUFjLENBQUNXLElBQWYsQ0FBb0JNLFlBQXBCLEVBQWtDUSxHQUFsQyxDQUFMLEVBQTZDeEIsTUFBTSxDQUFDVyxjQUFQLENBQXNCSyxZQUF0QixFQUFvQ1EsR0FBcEMsRUFBeUNILGtCQUFrQixDQUFDRyxHQUFELENBQTNEO0FBQzlDLEdBRkQ7QUFHRCxDQVBNLEM7OztBQVVBLE1BQU1DLHdCQUF3QixHQUFHLENBQUMsRUFBRUMsVUFBRixFQUFjQyxXQUFkLEVBQUQsS0FBaUM7O0FBRXZFLE9BQUssSUFBSWxCLEtBQVQsSUFBa0JpQixVQUFsQixFQUE4QjtBQUM1QixRQUFJLE9BQU9BLFVBQVUsQ0FBQ2pCLEtBQUQsQ0FBakIsSUFBNEIsUUFBNUIsSUFBd0MsT0FBT2tCLFdBQVcsQ0FBQ2xCLEtBQUQsQ0FBbEIsSUFBNkIsUUFBekUsRUFBbUZpQixVQUFVLENBQUNqQixLQUFELENBQVYsR0FBb0JULE1BQU0sQ0FBQ2MsTUFBUCxDQUFjYSxXQUFXLENBQUNsQixLQUFELENBQXpCLEVBQWtDaUIsVUFBVSxDQUFDakIsS0FBRCxDQUE1QyxDQUFwQjtBQUNuRmlCLElBQUFBLFVBQVUsQ0FBQ2pCLEtBQUQsQ0FBVixLQUFBaUIsVUFBVSxDQUFDakIsS0FBRCxDQUFWLEdBQXNCa0IsV0FBVyxDQUFDbEIsS0FBRCxDQUFqQztBQUNEO0FBQ0YsQ0FOTSxDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnXG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkgLy8gYWxsb3dzIHN1cHBvcnRpbmcgb2JqZWN0cyBkZWxlZmF0aW5nIG51bGwuXG5cbi8vIHN1cHBvcnRzIG11bHRpcGxlIG5lc3RlZCBwcm9wZXJ0aWVzIChwcm9wZXJ0eSBwYXRoIGFycmF5KVxuZXhwb3J0IGNvbnN0IG1lcmdlT3duTmVzdGVkUHJvcGVydHkgPSAoeyB0YXJnZXQsIHByb3BlcnR5UGF0aCwgdmFsdWUgfTogeyBwcm9wZXJ0eVBhdGg6IEFycmF5IHwgU3RyaW5nIC8qUHJvcGVydHkgcGF0aCovIH0pID0+IHtcbiAgYXNzZXJ0KHByb3BlcnR5UGF0aCwgJ+KAoiBgcHJvcGVydHlQYXRoYCBtdXN0IGJlIHBhc3NlZC4nKVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShwcm9wZXJ0eVBhdGgpKSBwcm9wZXJ0eVBhdGggPSBbcHJvcGVydHlQYXRoXVxuICBsZXQgdGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRcbiAgZm9yIChsZXQgaW5kZXggaW4gcHJvcGVydHlQYXRoKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldFByb3BlcnR5LCBwcm9wZXJ0eVBhdGhbaW5kZXhdKSkge1xuICAgICAgLy8gY3JlYXRlIHByb3BlcnR5IHBhdGggcmVjdXNpdmVseVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldFByb3BlcnR5LCBwcm9wZXJ0eVBhdGhbaW5kZXhdLCB7IGVudW1lcmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZToge30gfSlcbiAgICB9XG4gICAgdGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRQcm9wZXJ0eVtwcm9wZXJ0eVBhdGhbaW5kZXhdXVxuICB9XG4gIE9iamVjdC5hc3NpZ24odGFyZ2V0UHJvcGVydHksIHZhbHVlKVxuICByZXR1cm4gdGFyZ2V0XG59XG5cbi8vIHNldCBwcm9wZXJ0aWVzIG9ubHkgaWYgdGhleSBkbyBub3QgZXhpc3Qgb24gdGhlIHRhcmdldCBvYmplY3QuIE5vdCB1c2luZyBgT2JqZWN0LmVudGVyaWVzYCBiZWNhdXNlIGl0IGlnbm9yZXMgc3ltYm9scyBhcyBrZXlzLlxuZXhwb3J0IGNvbnN0IG1lcmdlTm9uZXhpc3RlbnRQcm9wZXJ0aWVzID0gKHRhcmdldE9iamVjdCwgZGVmYXVsdFZhbHVlOiBPYmplY3QpID0+IHtcbiAgLy8gSW1wb3J0YW50OiBmb3IgbG9vcHMgZG8gbm90IHN1cHBvcnQgc3ltYm9sIGtleXMgaXRlcmF0aW9uLCB0aGVyZWZvcmUga2V5cywgdGhlcmVmb3JlIGEgZGlmZmVyZW50IGFwcHJvYWNoIGlzIHRha2VuLlxuICBsZXQgcHJvcGVydHlLZXkgPSBbLi4uT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhkZWZhdWx0VmFsdWUpLCAuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkZWZhdWx0VmFsdWUpXVxuICBsZXQgcHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoZGVmYXVsdFZhbHVlKVxuICBwcm9wZXJ0eUtleS5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldE9iamVjdCwga2V5KSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldE9iamVjdCwga2V5LCBwcm9wZXJ0eURlc2NyaXB0b3Jba2V5XSlcbiAgfSlcbn1cblxuLy8gbWVyZ2UgYXJndW1lbnRzIGFycmF5IHRoYXQgbWF5IGhhdmUgb2JqZWN0IGl0ZW1zXG5leHBvcnQgY29uc3QgbWVyZ2VBcnJheVdpdGhPYmplY3RJdGVtID0gKHsgbGlzdFRhcmdldCwgbGlzdERlZmF1bHQgfSkgPT4ge1xuICAvLyBtZXJnZSBhcmd1bWVudHMgd2l0aCBkZWZhdWx0IHBhcmFtZXRlcnNcbiAgZm9yIChsZXQgaW5kZXggaW4gbGlzdFRhcmdldCkge1xuICAgIGlmICh0eXBlb2YgbGlzdFRhcmdldFtpbmRleF0gPT0gJ29iamVjdCcgJiYgdHlwZW9mIGxpc3REZWZhdWx0W2luZGV4XSA9PSAnb2JqZWN0JykgbGlzdFRhcmdldFtpbmRleF0gPSBPYmplY3QuYXNzaWduKGxpc3REZWZhdWx0W2luZGV4XSwgbGlzdFRhcmdldFtpbmRleF0pXG4gICAgbGlzdFRhcmdldFtpbmRleF0gfHw9IGxpc3REZWZhdWx0W2luZGV4XVxuICB9XG59XG4iXX0=